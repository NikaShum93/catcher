<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Catcher Game</title>
  <style>
    :root{ --ui: #ffd700; --glow: #00f0ff; }
    html,body{height:100%}
    /* –§–û–ù –ò–ì–†–´ –í–°–ï–ì–î–ê –ü–†–û–ó–†–ê–ß–ù–´–ô –ü–û –£–ú–û–õ–ß–ê–ù–ò–Æ */
    body{ margin:0; background: transparent !important; color:#fff; overflow:hidden; font-family:system-ui,sans-serif; }
    #game{ position:relative; width:100%; height:100%; overflow:hidden; }

    /* --- HUD --- */
    .hud{
      position:fixed; left:12px; top:12px; right:12px; display:flex; gap:12px; 
      justify-content:space-between; font-weight:700; z-index:20; pointer-events:none;
    }
    
    .badge{
      /* –õ–µ–≥–∫–∏–π —ç—Ñ—Ñ–µ–∫—Ç —Å—Ç–µ–∫–ª–∞ –∏ –¥–ª—è HUD */
      background: rgba(17, 17, 17, 0.7);              
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      border: 1px solid rgba(255, 255, 255, 0.2);        
      border-radius: 8px;                    
      padding: 8px 16px; 
      color: #fff;                    
      font-size: 16px;
      letter-spacing: 0.5px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
    }
    
    .levelTitle{ 
      color: var(--ui);              
      text-transform: uppercase;
      max-width: 50%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; 
    }

    /* --- –ò–ì–†–û–ö --- */
    #player {
      position: absolute; z-index: 100; pointer-events: none; 
      background-position: center; background-size: contain; background-repeat: no-repeat; will-change: left, top;
    }
    .touch-zone { position: fixed; z-index: 5; }

    /* --- –≠–ö–†–ê–ù–´ (–°–¢–ï–ö–õ–û) --- */
    .overlay{
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center; flex-direction:column;
      /* –¢–µ–º–Ω—ã–π –ø–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π —Ñ–æ–Ω –¥–ª—è –≤—Å–µ–≥–æ —ç–∫—Ä–∞–Ω–∞ */
      background: rgba(0,0,0,0.4); 
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      z-index:500;
    }
    
    .overlay .panel{
      /* –≠–§–§–ï–ö–¢ –°–¢–ï–ö–õ–ê (iOS Style) */
      background: rgba(30, 30, 30, 0.65); 
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.15);
      
      color:#fff; 
      border-radius:24px; /* –ë–æ–ª–µ–µ –∫—Ä—É–≥–ª—ã–µ —É–≥–ª—ã */
      padding:40px; text-align:center; 
      box-shadow: 0 20px 50px rgba(0,0,0,0.5);
      max-width: 480px; width: 90%;
      position: relative; z-index: 501;
      max-height: 90vh; overflow-y: auto;
    }
    .overlay h2{ margin:0 0 10px; font-size:32px; color:var(--ui); text-shadow: 0 2px 10px rgba(0,0,0,0.5); }
    
    .overlay h3.rank { 
      margin: 0 0 15px; font-size: 24px; font-weight: 900;
      background: linear-gradient(90deg, #fff, var(--glow), #fff); 
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      text-transform: uppercase; letter-spacing: 1px;
      animation: pulseRank 2s infinite;
    }
    @keyframes pulseRank { 0%{opacity:0.8; transform:scale(0.98)} 50%{opacity:1; transform:scale(1.02)} 100%{opacity:0.8; transform:scale(0.98)} }

    .stats-grid {
      display: grid; grid-template-columns: 1fr; gap: 8px;
      background: rgba(0,0,0,0.2); padding: 15px; border-radius: 12px;
      margin-bottom: 25px; font-size: 15px;
      border: 1px solid rgba(255,255,255,0.05);
    }
    .stats-row { display: flex; justify-content: space-between; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 4px; }
    .stats-row:last-child { border-bottom: none; padding-bottom: 0; margin-top: 5px; font-size: 18px; color: var(--ui); font-weight: bold; }

    .overlay img.feedback-img { max-width: 100%; max-height: 180px; border-radius: 12px; margin-bottom: 15px; object-fit: contain; }
    
    .overlay button{
      background: var(--ui); 
      color:#000; border:0; border-radius:12px; 
      padding:16px 32px; font-size:18px; font-weight:800; cursor:pointer; 
      transition: all 0.2s;
      box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3);
    }
    .overlay button:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(255, 215, 0, 0.5); background: #ffea00; }

    /* --- –≠–õ–ï–ú–ï–ù–¢–´ --- */
    .item{
      position:absolute; transform:translateZ(0);
      display:inline-flex; align-items:center; justify-content:center;
      min-width:100px; min-height:80px; padding:0; user-select:none; cursor:pointer;
      z-index: 10; box-sizing: border-box; 
    }
    
    .item .bg{
      position:absolute; inset:0; background: transparent; z-index: 0;
      /* –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï –û–ë–†–ï–ó–ö–ò –ò –ì–ò–ì–ê–ù–¢–°–ö–û–ì–û –ú–ê–ù–ì–û */
      background-position:center !important; 
      background-size: contain !important; /* –í–ø–∏—Å—ã–≤–∞–µ–º –∫–∞—Ä—Ç–∏–Ω–∫—É —Ü–µ–ª–∏–∫–æ–º */
      background-repeat: no-repeat !important;
      background-color: transparent !important; /* –£–±–∏—Ä–∞–µ–º –±–µ–ª—ã–µ —Ñ–æ–Ω—ã */
      border-radius: 12px; transition: filter .15s;
    }
    
    .item .content{
      position:relative; z-index: 2; 
      display:flex; align-items:center; justify-content:center;
      text-align:center; padding: 12px;
      width: var(--cw, auto); height: var(--ch, auto);
      text-shadow: none !important; font-weight: 700; line-height: 1.2;
    }
    
    .item .content img{ width:100%; height:100%; object-fit:contain; pointer-events:none; }
    
    .shape-rect .bg { border-radius:6px }
    .shape-rounded .bg { border-radius:20px }
    .shape-circle .bg { border-radius:50% }
    .shape-diamond .bg { clip-path:polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%) }
    .shape-star .bg { clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%); }
    
    .fx-shadow .bg{ box-shadow:0 8px 20px rgba(0,0,0,0.3) }
    .fx-glow .bg{ box-shadow:0 0 15px var(--glow) } 
    .fx-3d .bg{ box-shadow:0 6px 0 rgba(0,0,0,0.2) }

    .score-float{
      position:fixed; z-index:30; font-weight:900; font-size:24px;
      text-shadow: 1px 1px 0 #000;
      animation:floatUp .8s ease-out forwards; pointer-events:none;
    }
    @keyframes floatUp{ 0%{ transform:translate(-50%,0); opacity:1 } 100%{ transform:translate(-50%,-60px); opacity:0 } }
    
    .caught{ transform: scale(1.1); opacity: 0; transition: all 0.2s; }
    .tint-red .bg { background-color: rgba(255,0,0,0.7) !important; border-radius: 50%; } /* –ö—Ä–∞—Å–Ω—ã–π —Ç–∏–Ω—Ç –ø—Ä–∏ –æ—à–∏–±–∫–µ */

    .firework { position: absolute; width: 6px; height: 6px; border-radius: 50%; pointer-events: none; z-index: 999; }
  </style>
</head>
<body>
  <div class="hud">
    <div class="badge levelTitle" id="hudLevel">...</div>
    <div class="badge timer" id="hudTimer">00</div>
    <div class="badge score" id="hudScore">0</div>
  </div>
  <div id="game">
    </div>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

  <script>
    const $ = sel => document.querySelector(sel);
    const rnd = (a,b)=> a + Math.random()*(b-a);
    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

    // --- –°–ö–û–†–û–°–¢–¨ (–ë–ê–õ–ê–ù–° 0.2 ... 3.5) ---
    function computeSpeedParams(S){
      const s = clamp(Number(S||5), 1, 10);
      const t = (s - 1) / 9; 
      const vel = 0.2 + (3.5 - 0.2) * Math.pow(t, 1.5); 
      const spawn = 2500 - (2500 - 600) * t;
      const basePts = 5 + (50 - 5) * t;
      return { vel, spawn, basePts: Math.round(basePts) };
    }
    
    // --- –õ–û–ö–ê–õ–ò–ó–ê–¶–ò–Ø –ò –†–ê–ù–ì–ò ---
    const I18N = {
      ru: { 
        ranks: ["–ù–æ–≤–∏—á–æ–∫", "–£—á–µ–Ω–∏–∫", "–ù–∏–Ω–¥–∑—è", "–ì—Ä–∞–Ω–¥–º–∞—Å—Ç–µ—Ä", "–ë–û–ì –†–ï–ê–ö–¶–ò–ò"],
        stats: { hits: "–ü–æ–π–º–∞–Ω–æ", wrong: "–û—à–∏–±–∫–∏", missed: "–ü—Ä–æ–ø—É—â–µ–Ω–æ", total: "–°–ß–Å–¢" }
      },
      en: { 
        ranks: ["Novice", "Apprentice", "Ninja", "Grandmaster", "GOD OF REACTION"],
        stats: { hits: "Caught", wrong: "Mistakes", missed: "Missed", total: "SCORE" }
      },
      de: { ranks: ["Anf√§nger", "Lehrling", "Ninja", "Gro√ümeister", "REAKTIONSGOTT"], stats: { hits: "Gefangen", wrong: "Fehler", missed: "Verpasst", total: "PUNKTE" } },
      es: { ranks: ["Novato", "Aprendiz", "Ninja", "Gran Maestro", "DIOS DE LA REACCI√ìN"], stats: { hits: "Atrapados", wrong: "Errores", missed: "Perdidos", total: "PUNTOS" } },
      it: { ranks: ["Novizio", "Apprendista", "Ninja", "Gran Maestro", "DIO DELLA REAZIONE"], stats: { hits: "Presi", wrong: "Errori", missed: "Persi", total: "PUNTI" } },
      fr: { ranks: ["Novice", "Apprenti", "Ninja", "Grand Ma√Ætre", "DIEU DE LA R√âACTION"], stats: { hits: "Attrap√©s", wrong: "Erreurs", missed: "Rat√©s", total: "SCORE" } },
      zh: { ranks: ["Êñ∞Êâã", "Â≠¶Âæí", "ÂøçËÄÖ", "ÁâπÁ∫ßÂ§ßÂ∏à", "ÂèçÂ∫î‰πãÁ•û"], stats: { hits: "ÊçïËé∑", wrong: "ÈîôËØØ", missed: "ÈîôËøá", total: "ÊÄªÂàÜ" } },
      ja: { ranks: ["ÂàùÂøÉËÄÖ", "Ë¶ãÁøí„ÅÑ", "ÂøçËÄÖ", "„Ç∞„É©„É≥„Éâ„Éû„Çπ„Çø„Éº", "ÂèçÂ∞ÑÁ•ûÁµå„ÅÆÁ•û"], stats: { hits: "ÊçïÁç≤", wrong: "„Éü„Çπ", missed: "ÈÄÉ„Åó„Åü", total: "„Çπ„Ç≥„Ç¢" } },
      math: { ranks: ["Novice", "Apprentice", "Ninja", "Grandmaster", "GOD OF REACTION"], stats: { hits: "Solved", wrong: "Errors", missed: "Missed", total: "SCORE" } }
    };

    function t(lang, key){
      const dict = I18N[lang] || I18N.en;
      return dict[key] || I18N.en[key];
    }

    const SND = {
      pop: new Audio("https://github.com/NikaShum93/snow_quiz/raw/refs/heads/main/pop.mp3"),
      wrong: new Audio("https://github.com/NikaShum93/snow_quiz/raw/refs/heads/main/wrong.mp3"),
      win: new Audio("https://github.com/NikaShum93/snow_quiz/raw/refs/heads/main/win.mp3")
    };
    
    let cfg = null;
    let playerNode = null, playerPos = {x:0, y:0, v:0}, keys = {neg:false, pos:false}; // neg/pos = left/right OR up/down
    let score=0, hits=0, wrongClicks=0, missed=0, currentLevel=0, running=false;
    let LANG = 'ru'; 
    let SPEED = { vel: 1.5, spawn: 1000, basePts: 20 };
    let IS_HORIZONTAL = false;
    
    // –í–ê–ñ–ù–û: –¢–∞–π–º–µ—Ä —Å–ø–∞–≤–Ω–∞, —á—Ç–æ–±—ã —É–±–∏–≤–∞—Ç—å –µ–≥–æ –ø—Ä–∏ —Å–º–µ–Ω–µ —É—Ä–æ–≤–Ω—è
    let spawnTimer = null;

    const params = new URLSearchParams(location.search);
    const ID = params.get('id');
    const URL = `https://nikashum93.github.io/texts/data/${ID}.json`;

    if(!ID) document.body.innerHTML = "<h2 style='text-align:center; color:#fff; margin-top:50px'>–ù–µ—Ç ID –∏–≥—Ä—ã.</h2>";
    else fetch(URL).then(r=>r.json()).then(startApp).catch(console.error);

    function startApp(data){
      cfg = data;
      LANG = cfg.language || 'ru';
      SPEED = computeSpeedParams(cfg.speed);
      
      const dir = cfg.direction || 'down';
      IS_HORIZONTAL = (dir === 'left' || dir === 'right');
      
      if(cfg.font) {
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = `https://fonts.googleapis.com/css2?family=${cfg.font.replace(/ /g,'+')}:wght@400;700&display=swap`;
        document.head.appendChild(link);
      }
      if(cfg.style?.glowColor) document.documentElement.style.setProperty('--glow', cfg.style.glowColor);
      
      setupBackground();
      setupPlayer();
      
      const ov = document.createElement('div'); ov.className='overlay';
      const tStart = cfg.start?.title || 'Game';
      const bStart = cfg.start?.btnText || 'Start';
      ov.innerHTML = `<div class="panel"><h2>${tStart}</h2><button id="btnStart">${bStart}</button></div>`;
      document.body.appendChild(ov);
      $('#btnStart').onclick = () => { ov.remove(); startGame(); };
    }

    function setupBackground(){
      const img = document.createElement('div');
      img.style.cssText = "position:fixed;inset:0;z-index:-1;background-size:cover;background-position:center;transition:background-image 0.5s";
      document.body.appendChild(img);
      const list = cfg.style?.bgImages || [];
      
      if(list.length) img.style.backgroundImage = `url(${list[0]})`;
      else if(cfg.style?.bgImage) img.style.backgroundImage = `url(${cfg.style.bgImage})`;
      else img.style.backgroundColor = 'transparent'; // –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü—Ä–æ–∑—Ä–∞—á–Ω—ã–π —Ñ–æ–Ω –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
      
      window.nextBg = () => { if(list.length) img.style.backgroundImage = `url(${list[Math.floor(Math.random()*list.length)]})`; };
    }

    function setupPlayer(){
      if(!cfg.player?.img) return; 
      playerNode = document.createElement('div');
      playerNode.id = 'player';
      playerNode.style.width = (cfg.player.width||100)+'px';
      playerNode.style.height = (cfg.player.height||100)+'px';
      playerNode.style.backgroundImage = `url(${cfg.player.img})`;
      
      const dir = cfg.direction || 'down';
      
      // –ü–û–ó–ò–¶–ò–Ø –ò–ì–†–û–ö–ê
      if(IS_HORIZONTAL) {
         playerPos.y = window.innerHeight / 2;
         if(dir === 'left') {
            // –õ–æ–≤–µ—Ü —Å–ª–µ–≤–∞, –ª–µ—Ç–∏—Ç —Å–ª–µ–≤–∞ -> –∏–≥—Ä–æ–∫ —Å–ª–µ–≤–∞
            playerNode.style.left = '20px';
            playerNode.style.top = '50%';
         } else {
            // –õ–æ–≤–µ—Ü —Å–ø—Ä–∞–≤–∞
            playerNode.style.right = '20px';
            playerNode.style.top = '50%';
         }
      } else {
         // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ
         playerPos.x = window.innerWidth / 2;
         if(dir === 'down') {
            playerNode.style.bottom = '0px';
            playerNode.style.left = '50%';
         } else {
            playerNode.style.top = '0px'; // –¥–ª—è —Ä–µ–∂–∏–º–∞ —Å–Ω–∏–∑—É-–≤–≤–µ—Ä—Ö (–ø—É–∑—ã—Ä–∏)
            playerNode.style.left = '50%';
         }
      }
      
      $('#game').appendChild(playerNode);
      setupControls();
      requestAnimationFrame(loopPlayer);
    }

    function setupControls(){
      // –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞
      window.onkeydown = e => { 
         if(IS_HORIZONTAL) {
            if(e.key==='ArrowUp') keys.neg=true; 
            if(e.key==='ArrowDown') keys.pos=true;
         } else {
            if(e.key==='ArrowLeft') keys.neg=true; 
            if(e.key==='ArrowRight') keys.pos=true;
         }
      };
      window.onkeyup = e => {
         if(IS_HORIZONTAL) {
            if(e.key==='ArrowUp') keys.neg=false; 
            if(e.key==='ArrowDown') keys.pos=false;
         } else {
            if(e.key==='ArrowLeft') keys.neg=false; 
            if(e.key==='ArrowRight') keys.pos=false;
         }
      };

      // –¢–∞—á –∑–æ–Ω—ã
      const gameDiv = $('#game');
      const z1 = document.createElement('div'); z1.className='touch-zone';
      const z2 = document.createElement('div'); z2.className='touch-zone';
      
      if(IS_HORIZONTAL) {
         // –í–µ—Ä—Ö–Ω—è—è –ø–æ–ª–æ–≤–∏–Ω–∞ = –í–í–ï–†–• (neg), –ù–∏–∂–Ω—è—è = –í–ù–ò–ó (pos)
         z1.style.cssText = "top:0; left:0; right:0; height:50%";
         z2.style.cssText = "bottom:0; left:0; right:0; height:50%";
      } else {
         // –õ–µ–≤–∞—è = –í–õ–ï–í–û (neg), –ü—Ä–∞–≤–∞—è = –í–ü–†–ê–í–û (pos)
         z1.style.cssText = "top:0; left:0; bottom:0; width:50%";
         z2.style.cssText = "top:0; right:0; bottom:0; width:50%";
      }
      
      const bind = (el, k) => {
        el.ontouchstart = e => { e.preventDefault(); keys[k]=true; };
        el.ontouchend = e => { e.preventDefault(); keys[k]=false; };
        el.onmousedown = () => keys[k]=true;
        el.onmouseup = () => keys[k]=false;
        el.onmouseleave = () => keys[k]=false;
      };
      bind(z1, 'neg'); bind(z2, 'pos');
      
      gameDiv.appendChild(z1); gameDiv.appendChild(z2);
    }

    function loopPlayer(){
      if(!playerNode || !running) { requestAnimationFrame(loopPlayer); return; }
      
      if(keys.neg) playerPos.v -= 1.5;
      if(keys.pos) playerPos.v += 1.5;
      playerPos.v *= 0.85;

      if(IS_HORIZONTAL) {
         playerPos.y += playerPos.v;
         const h = playerNode.offsetHeight;
         if(playerPos.y < h/2) { playerPos.y = h/2; playerPos.v=0; }
         if(playerPos.y > window.innerHeight - h/2) { playerPos.y = window.innerHeight - h/2; playerPos.v=0; }
         playerNode.style.top = playerPos.y + 'px';
         playerNode.style.transform = 'translateY(-50%)'; // –¶–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ
      } else {
         playerPos.x += playerPos.v;
         const w = playerNode.offsetWidth;
         if(playerPos.x < w/2) { playerPos.x = w/2; playerPos.v=0; }
         if(playerPos.x > window.innerWidth - w/2) { playerPos.x = window.innerWidth - w/2; playerPos.v=0; }
         playerNode.style.left = playerPos.x + 'px';
         playerNode.style.transform = 'translateX(-50%)'; // –¶–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ
      }
      
      checkCollisions();
      requestAnimationFrame(loopPlayer);
    }

    function startGame(){
      score=0; hits=0; wrongClicks=0; missed=0; currentLevel=0; running=true;
      $('#hudScore').textContent = '0';
      startLevel();
    }

    function startLevel(){
      // 1. –û–ß–ò–°–¢–ö–ê –ü–†–ï–î–´–î–£–©–ï–ì–û –£–†–û–í–ù–Ø
      if(spawnTimer) clearTimeout(spawnTimer); // –£–±–∏–≤–∞–µ–º —Å–ø–∞–≤–Ω–µ—Ä —Å—Ç–∞—Ä–æ–≥–æ —É—Ä–æ–≤–Ω—è
      document.querySelectorAll('.item').forEach(e=>e.remove()); // –£–±–∏—Ä–∞–µ–º —Å—Ç–∞—Ä—ã–µ –ø—Ä–µ–¥–º–µ—Ç—ã
      
      currentLevel++;
      if(currentLevel > cfg.levels.length) { gameOver(); return; }
      window.nextBg();
      const lv = cfg.levels[currentLevel-1];
      $('#hudLevel').textContent = lv.target || `${currentLevel}`;
      
      let time = lv.timer || 30;
      $('#hudTimer').textContent = time;
      
      const timer = setInterval(() => {
        if(!running) return clearInterval(timer);
        time--;
        $('#hudTimer').textContent = time;
        if(time <= 0) {
          clearInterval(timer);
          clearTimeout(spawnTimer); // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–ø–∞–≤–Ω
          document.querySelectorAll('.item').forEach(e=>e.remove());
          showLevelComplete();
        }
      }, 1000);
      spawnLoop(lv);
    }

    function spawnLoop(lv){
      const pool = [...lv.correct.map(v=>({v,g:true})), ...lv.wrong.map(v=>({v,g:false}))];
      const next = () => {
         if(!running) return;
         if(document.querySelectorAll('.item').length < 6) drop(pool[Math.floor(Math.random()*pool.length)]);
         // –°–æ—Ö—Ä–∞–Ω—è–µ–º ID —Ç–∞–π–º–µ—Ä–∞, —á—Ç–æ–±—ã —É–±–∏—Ç—å –µ–≥–æ –ø—Ä–∏ —Å–º–µ–Ω–µ —É—Ä–æ–≤–Ω—è
         spawnTimer = setTimeout(next, SPEED.spawn);
      };
      next();
    }

    function drop(data){
      const el = document.createElement('div');
      const sty = cfg.style;
      el.className = `item shape-${sty.shape} ${sty.shadow?'fx-shadow':''} ${sty.fx3d?'fx-3d':''} ${sty.glow?'fx-glow':''}`;
      el.dataset.good = data.g; // –í–æ—Ç –∑–¥–µ—Å—å –¥–∞–Ω–Ω—ã–µ –ø—Ä–∏–≤—è–∑—ã–≤–∞—é—Ç—Å—è –∫ —ç–ª–µ–º–µ–Ω—Ç—É

      const bg = document.createElement('div'); bg.className = 'bg';
      if(sty.bgImages?.length) bg.style.backgroundImage = `url(${sty.bgImages[0]})`;
      else if(sty.bgColor) bg.style.backgroundColor = sty.bgColor;
      else bg.style.backgroundColor = 'transparent'; 
      bg.style.opacity = sty.opacity || 1;
      if(sty.borderOn) bg.style.border = `2px solid ${sty.borderColor}`;

      const con = document.createElement('div'); con.className = 'content';
      if(data.v.startsWith('http')){
        con.innerHTML = `<img src="${data.v}">`;
        con.style.setProperty('--cw', sty.imgBox+'px'); con.style.setProperty('--ch', sty.imgBox+'px');
      } else {
        con.textContent = data.v;
        con.style.fontSize = (cfg.fontSize||24)+'px';
        con.style.fontFamily = cfg.font;
        con.style.color = cfg.textColor;
        if(cfg.language==='math') { con.textContent = `\\(${data.v}\\)`; MathJax.typesetPromise([con]); }
      }
      el.appendChild(bg); el.appendChild(con);
      
      const dir = cfg.direction || 'down';
      
      // –°–¢–ê–†–¢–û–í–ê–Ø –ü–û–ó–ò–¶–ò–Ø
      if(IS_HORIZONTAL) {
         // –ü–æ Y —Ä–∞–Ω–¥–æ–º–Ω–æ
         el.style.top = rnd(60, window.innerHeight-60) + 'px';
         if(dir === 'left') el.style.left = (window.innerWidth + 100) + 'px'; // –õ–µ—Ç–∏—Ç –Ω–∞–ª–µ–≤–æ
         else el.style.left = '-150px'; // –õ–µ—Ç–∏—Ç –Ω–∞–ø—Ä–∞–≤–æ
      } else {
         // –ü–æ X —Ä–∞–Ω–¥–æ–º–Ω–æ
         el.style.left = rnd(60, window.innerWidth-60) + 'px';
         if(dir === 'down') el.style.top = '-150px';
         else el.style.top = (window.innerHeight + 50) + 'px';
      }
      
      if(!playerNode) el.onclick = () => catchItem(el);
      $('#game').appendChild(el);
      
      let t = Math.random() * 100;
      const speed = SPEED.vel;
      
      function fall(){
        if(!el.parentNode) return;
        t += 0.05;
        const sway = Math.sin(t) * 25; 
        
        if(IS_HORIZONTAL) {
           let x = parseFloat(el.style.left);
           if(dir === 'left') x -= speed; else x += speed;
           el.style.left = x + 'px';
           el.style.transform = `translateY(${sway}px)`;
           
           // –£–¥–∞–ª–µ–Ω–∏–µ
           if(x < -200 || x > window.innerWidth+200) {
              if(el.dataset.good === 'true') missed++;
              el.remove();
           } else requestAnimationFrame(fall);
           
        } else {
           let y = parseFloat(el.style.top);
           if(dir === 'down') y += speed; else y -= speed;
           
           // –ì—Ä–∞–Ω–∏—Ü—ã –ø–æ–∫–∞—á–∏–≤–∞–Ω–∏—è
           let curX = parseFloat(el.style.left);
           const elW = el.offsetWidth || 100;
           if(curX + sway < 10) el.style.left = (curX + (10 - (curX+sway))) + 'px';
           else if (curX + sway > window.innerWidth - elW - 10) el.style.left = (curX - ((curX+sway) - (window.innerWidth - elW - 10))) + 'px';
           
           el.style.top = y + 'px';
           el.style.transform = `translateX(${sway}px)`;
           
           if(y > window.innerHeight+100 || y < -200) {
              if(el.dataset.good === 'true') missed++;
              el.remove();
           } else requestAnimationFrame(fall);
        }
      }
      requestAnimationFrame(fall);
    }

    function checkCollisions(){
      const pRect = playerNode.getBoundingClientRect();
      // –•–∏—Ç–±–æ–∫—Å —á—É—Ç—å –º–µ–Ω—å—à–µ –≤–∏–∑—É–∞–ª–∞
      const hit = { 
         l: pRect.left + pRect.width*0.2, 
         r: pRect.right - pRect.width*0.2, 
         t: pRect.top + pRect.height*0.2, 
         b: pRect.bottom - pRect.height*0.2 
      };

      document.querySelectorAll('.item').forEach(el => {
        if(el.dataset.caught) return;
        const r = el.getBoundingClientRect();
        if(!(hit.r < r.left || hit.l > r.right || hit.b < r.top || hit.t > r.bottom)){
            catchItem(el);
        }
      });
    }

    function catchItem(el){
      el.dataset.caught = true;
      const isGood = el.dataset.good === 'true';
      if(isGood) {
        score += SPEED.basePts; hits++;
        floatText(el, "+"+SPEED.basePts, "#0f0");
        try{ SND.pop.currentTime=0; SND.pop.play() }catch(e){}
      } else {
        score = Math.max(0, score - SPEED.basePts); wrongClicks++;
        floatText(el, "-"+SPEED.basePts, "#f00");
        try{ SND.wrong.currentTime=0; SND.wrong.play() }catch(e){}
        if(playerNode) {
             playerNode.style.filter = "grayscale(1) sepia(1) hue-rotate(-50deg) saturate(5)";
             setTimeout(()=>playerNode.style.filter="", 300);
        }
        el.classList.add('tint-red');
        setTimeout(()=>el.classList.remove('tint-red'), 300);
      }
      $('#hudScore').textContent = score;
      el.classList.add('caught');
      setTimeout(()=>el.remove(), 200);
    }

    function floatText(el, txt, col){
       const f = document.createElement('div'); f.className='score-float';
       f.textContent = txt; f.style.color = col;
       const r = el.getBoundingClientRect();
       f.style.left = (r.left+r.width/2)+'px'; f.style.top = r.top+'px';
       document.body.appendChild(f);
       setTimeout(()=>f.remove(), 800);
    }

    function showLevelComplete(){
      const ov = document.createElement('div'); ov.className='overlay';
      try{ SND.win.currentTime=0; SND.win.play() }catch(e){}
      ov.innerHTML = `<div class="panel"><h2>Level Complete!</h2><button onclick="this.closest('.overlay').remove();startLevel()">Next</button></div>`;
      document.body.appendChild(ov);
      launchFireworks(15);
    }
    
    function gameOver(){
      const ov = document.createElement('div'); ov.className='overlay';
      try{ SND.win.currentTime=0; SND.win.play() }catch(e){}
      
      const ranks = t(LANG, 'ranks');
      let rankIdx = 0;
      if (score >= 50) rankIdx = 1;
      if (score >= 150) rankIdx = 2;
      if (score >= 300) rankIdx = 3;
      if (score >= 500) rankIdx = 4;
      const rankName = ranks[rankIdx];

      const TXT = t(LANG, 'stats');
      const fbVal = cfg.finalFeedback || 'Good Job!';
      let fbContent = '';
      if(/^https?:\/\//i.test(fbVal)) fbContent = `<img src="${fbVal}" class="feedback-img">`;
      else fbContent = `<h2>${fbVal}</h2>`;

      ov.innerHTML = `
        <div class="panel">
           ${fbContent}
           <h3 class="rank">${rankName}</h3>
           <div class="stats-grid">
             <div class="stats-row"><span>‚úÖ ${TXT.hits}</span> <b>${hits}</b></div>
             <div class="stats-row"><span>‚ùå ${TXT.wrong}</span> <b>${wrongClicks}</b></div>
             <div class="stats-row"><span>üí® ${TXT.missed}</span> <b>${missed}</b></div>
             <div class="stats-row"><span>üèÜ ${TXT.total}</span> <b>${score}</b></div>
           </div>
           <button onclick="location.reload()">Replay</button>
        </div>`;
      document.body.appendChild(ov);
      launchFireworks(40);
    }

    function launchFireworks(count){
       for(let i=0; i<count; i++){
          setTimeout(()=>{
             const x = Math.random() * window.innerWidth;
             const y = Math.random() * window.innerHeight * 0.6;
             createFirework(x, y);
          }, i * 300);
       }
    }

    function createFirework(x, y) {
      const colors = ['#ff0', '#f0f', '#0ff', '#0f0', '#f00'];
      const color = colors[Math.floor(Math.random() * colors.length)];
      for (let i = 0; i < 20; i++) {
        const p = document.createElement('div');
        p.className = 'firework';
        p.style.backgroundColor = color;
        p.style.left = x + 'px';
        p.style.top = y + 'px';
        const angle = (Math.PI * 2 * i) / 20;
        const speed = Math.random() * 5 + 2;
        const vx = Math.cos(angle) * speed;
        const vy = Math.sin(angle) * speed;
        document.body.appendChild(p);
        let life = 100;
        const anim = setInterval(() => {
           const l = parseFloat(p.style.left);
           const t = parseFloat(p.style.top);
           p.style.left = (l + vx) + 'px';
           p.style.top = (t + vy) + 'px';
           p.style.opacity = life / 100;
           life -= 2;
           if(life <= 0) { clearInterval(anim); p.remove(); }
        }, 20);
      }
    }
  </script>
</body>
</html>
