<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Catcher Game</title>
  <style>
    :root{ --ui: #ffd700; --glow: #00f0ff; }
    
    /* === –ë–ê–ó–ê === */
    html,body{height:100%}
    /* –§–û–ù –ò–ì–†–´ –ü–û–õ–ù–û–°–¢–¨–Æ –ü–†–û–ó–†–ê–ß–ù–´–ô */
    body{ margin:0; background: transparent !important; color:#fff; overflow:hidden; font-family:system-ui,sans-serif; }
    #game{ position:relative; width:100%; height:100%; overflow:hidden; }

    /* === HUD === */
    .hud{
      position:fixed; left:12px; top:12px; right:12px; display:none; /* –°–∫—Ä—ã—Ç –¥–æ —Å—Ç–∞—Ä—Ç–∞ */
      justify-content:space-between; font-weight:700; z-index:20; pointer-events:none;
      gap:12px;
    }
    .badge{
      background: rgba(17, 17, 17, 0.85); 
      border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; padding: 8px 16px; 
      color: #fff; font-size: 16px; letter-spacing: 0.5px; box-shadow: 0 4px 6px rgba(0,0,0,0.3);
    }
    .levelTitle{ color: var(--ui); max-width: 50%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

    /* === –ò–ì–†–û–ö === */
    #player {
      position: absolute; z-index: 100; pointer-events: none; display: none;
      background-position: center; background-size: contain; background-repeat: no-repeat; will-change: left, top;
    }
    .touch-zone { position: fixed; z-index: 5; }

    /* === –û–í–ï–†–õ–ï–ò (–ü–†–û–ó–†–ê–ß–ù–´–ô –§–û–ù!) === */
    .overlay{
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center; flex-direction:column;
      background: transparent !important; /* –£–ë–†–ê–õ–ò –ó–ê–¢–ï–ú–ù–ï–ù–ò–ï */
      z-index:500;
      pointer-events: auto;
    }
    .overlay .panel{
      background: rgba(20, 20, 20, 0.9); /* –°–∞–º–∞ –ø–ª–∞—à–∫–∞ —Ç–µ–º–Ω–∞—è, —á—Ç–æ–±—ã —Ç–µ–∫—Å—Ç —á–∏—Ç–∞–ª—Å—è */
      border: 1px solid rgba(255, 255, 255, 0.15); color:#fff; border-radius:24px;
      padding:40px; text-align:center; box-shadow: 0 10px 40px rgba(0,0,0,0.6);
      max-width: 480px; width: 90%; position: relative; z-index: 501; max-height: 90vh; overflow-y: auto;
    }
    .overlay h2{ margin:0 0 10px; font-size:32px; color:var(--ui); text-shadow: 0 2px 10px rgba(0,0,0,0.5); }
    .overlay h3.rank { 
      margin: 0 0 15px; font-size: 24px; font-weight: 900;
      background: linear-gradient(90deg, #fff, var(--glow), #fff); -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      text-transform: uppercase; letter-spacing: 1px; animation: pulseRank 2s infinite;
    }
    @keyframes pulseRank { 0%{opacity:0.8; transform:scale(0.98)} 50%{opacity:1; transform:scale(1.02)} 100%{opacity:0.8; transform:scale(0.98)} }

    .stats-grid {
      display: grid; grid-template-columns: 1fr; gap: 8px;
      background: rgba(255,255,255,0.05); padding: 15px; border-radius: 12px; margin-bottom: 25px; font-size: 15px; border: 1px solid rgba(255,255,255,0.05);
    }
    .stats-row { display: flex; justify-content: space-between; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 4px; }
    .stats-row:last-child { border-bottom: none; padding-bottom: 0; margin-top: 5px; font-size: 18px; color: var(--ui); font-weight: bold; }
    .overlay img.feedback-img { max-width: 100%; max-height: 180px; border-radius: 12px; margin-bottom: 15px; object-fit: contain; }
    .overlay button{
      background: var(--ui); color:#000; border:0; border-radius:12px; 
      padding:16px 32px; font-size:18px; font-weight:800; cursor:pointer; 
      transition: all 0.2s; box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3);
    }
    .overlay button:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(255, 215, 0, 0.5); background: #ffea00; }

    /* === –ü–ê–î–ê–Æ–©–ò–ï –≠–õ–ï–ú–ï–ù–¢–´ === */
    .item{
      position:absolute; transform:translateZ(0);
      display:inline-flex; align-items:center; justify-content:center;
      padding:0; user-select:none; cursor:pointer; z-index: 10;
      box-sizing: border-box; 
      white-space: nowrap; /* –ß—Ç–æ–±—ã —Ç–µ–∫—Å—Ç –Ω–µ –ø–µ—Ä–µ–Ω–æ—Å–∏–ª—Å—è */
    }
    
    .item .bg{
      position:absolute; inset:0;
      background: transparent; opacity:1;
      border:0 solid #fff; box-shadow:none;
      transition:filter .15s ease;
      background-position:center !important;
      background-repeat:no-repeat !important;
      /* –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –†–∞—Å—Ç—è–≥–∏–≤–∞–µ–º –∫–∞—Ä—Ç–∏–Ω–∫—É —Ç–æ—á–Ω–æ –ø–æ–¥ —Ä–∞–∑–º–µ—Ä –±–æ–∫—Å–∞ */
      background-size: 100% 100% !important; 
    }
    
    .item .content{
      position:relative; z-index:1;
      display:flex; align-items:center; justify-content:center;
      text-align:center; line-height:1.15;
      width: 100%; height: 100%;
    }
    
    .item .content span{ display:inline-block; font-weight:800; }
    .item .content img{ width:100%; height:100%; object-fit:contain; pointer-events:none; }

    /* –§–æ—Ä–º—ã */
    .shape-rect .bg { border-radius:10px }
    .shape-rounded .bg { border-radius:20px }
    .shape-circle .bg { border-radius:50% }
    
    /* –≠—Ñ—Ñ–µ–∫—Ç—ã */
    .fx-shadow .bg{ box-shadow:0 10px 30px rgba(0,0,0,.55) }
    .fx-glow .bg{ box-shadow:0 0 18px var(--glow, #00f0ff), 0 0 28px rgba(0,0,0,.25) }
    
    .score-float{
      position:fixed; z-index:30; font-weight:900; font-size:24px;
      text-shadow: 1px 1px 0 #000; animation:floatUp .8s ease-out forwards; pointer-events:none;
    }
    @keyframes floatUp{ 0%{ transform:translate(-50%,0); opacity:1 } 100%{ transform:translate(-50%,-60px); opacity:0 } }
    
    .caught{ transform: scale(1.1); opacity: 0; transition: all 0.2s; }
    .tint-red .bg { filter: hue-rotate(-25deg) saturate(3) brightness(1.2); }
    .firework { position: absolute; width: 6px; height: 6px; border-radius: 50%; pointer-events: none; z-index: 999; }
  </style>
</head>
<body>
  <div class="hud">
    <div class="badge levelTitle" id="hudLevel">...</div>
    <div class="badge timer" id="hudTimer">00</div>
    <div class="badge score" id="hudScore">0</div>
  </div>
  <div id="game"></div>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

  <script>
    const $ = sel => document.querySelector(sel);
    const rnd = (a,b)=> a + Math.random()*(b-a);
    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

    // === –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –°–ö–û–†–û–°–¢–¨ (–ú–ï–î–õ–ï–ù–ù–ï–ï) ===
    function computeSpeedParams(S){
      // S –æ—Ç 1 –¥–æ 10. 
      // –ü—Ä–∏ S=1 —Å–∫–æ—Ä–æ—Å—Ç—å 0.5 (–æ—á–µ–Ω—å –º–µ–¥–ª–µ–Ω–Ω–æ)
      // –ü—Ä–∏ S=10 —Å–∫–æ—Ä–æ—Å—Ç—å 3.5 (–±—ã—Å—Ç—Ä–æ, –Ω–æ –Ω–µ "–≤ —Ç—Ä–∏ —Ä–∞–∑–∞")
      const s = clamp(Number(S||5), 1, 10);
      const t = (s - 1) / 9; 
      
      const vel = 0.5 + (3.5 - 0.5) * Math.pow(t, 1.2); 
      const spawn = 2000 - (2000 - 500) * t; // –°–ø–∞–≤–Ω –æ—Ç 2 —Å–µ–∫ –¥–æ 0.5 —Å–µ–∫
      const basePts = 5 + (50 - 5) * t;
      return { vel, spawn, basePts: Math.round(basePts) };
    }
    
    const I18N = {
      ru: { ranks: ["–ù–æ–≤–∏—á–æ–∫", "–£—á–µ–Ω–∏–∫", "–ù–∏–Ω–¥–∑—è", "–ì—Ä–∞–Ω–¥–º–∞—Å—Ç–µ—Ä", "–ë–û–ì –†–ï–ê–ö–¶–ò–ò"], stats: { hits: "–ü–æ–π–º–∞–Ω–æ", wrong: "–û—à–∏–±–∫–∏", missed: "–ü—Ä–æ–ø—É—â–µ–Ω–æ", total: "–°–ß–Å–¢" } },
      en: { ranks: ["Novice", "Apprentice", "Ninja", "Grandmaster", "GOD OF REACTION"], stats: { hits: "Caught", wrong: "Mistakes", missed: "Missed", total: "SCORE" } },
      math: { ranks: ["Novice", "Apprentice", "Ninja", "Grandmaster", "GOD OF REACTION"], stats: { hits: "Solved", wrong: "Errors", missed: "Missed", total: "SCORE" } }
    };

    function t(lang, key){
      const dict = I18N[lang] || I18N.en;
      return dict[key] || I18N.en[key];
    }

    const SND = {
      pop: new Audio("https://github.com/NikaShum93/snow_quiz/raw/refs/heads/main/pop.mp3"),
      wrong: new Audio("https://github.com/NikaShum93/snow_quiz/raw/refs/heads/main/wrong.mp3"),
      win: new Audio("https://github.com/NikaShum93/snow_quiz/raw/refs/heads/main/win.mp3")
    };
    
    let cfg = null;
    let playerNode = null, playerPos = {x:0, y:0, v:0}, keys = {neg:false, pos:false}; 
    let score=0, hits=0, wrongClicks=0, missed=0, currentLevel=0, running=false;
    let LANG = 'ru'; 
    let SPEED = { vel: 1.0, spawn: 1500, basePts: 20 };
    let IS_HORIZONTAL = false;
    let spawnTimer = null;
    let lastZone = -1;

    const params = new URLSearchParams(location.search);
    const ID = params.get('id');
    const URL = `https://nikashum93.github.io/texts/data/${ID}.json`;

    if(!ID) document.body.innerHTML = "<h2 style='text-align:center; color:#fff; margin-top:50px'>–ù–µ—Ç ID –∏–≥—Ä—ã.</h2>";
    else fetch(URL).then(r=>r.json()).then(startApp).catch(console.error);

    function startApp(data){
      cfg = data;
      LANG = cfg.language || 'ru';
      SPEED = computeSpeedParams(cfg.speed);
      
      const dir = cfg.direction || 'down';
      IS_HORIZONTAL = (dir === 'left' || dir === 'right');
      
      if(cfg.font) {
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = `https://fonts.googleapis.com/css2?family=${cfg.font.replace(/ /g,'+')}:wght@400;700&display=swap`;
        document.head.appendChild(link);
      }
      if(cfg.style?.glowColor) document.documentElement.style.setProperty('--glow', cfg.style.glowColor);
      
      setupPlayer();
      
      const ov = document.createElement('div'); ov.className='overlay';
      const tStart = cfg.start?.title || 'Game';
      const bStart = cfg.start?.btnText || 'Start';
      ov.innerHTML = `<div class="panel"><h2>${tStart}</h2><button id="btnStart">${bStart}</button></div>`;
      document.body.appendChild(ov);
      $('#btnStart').onclick = () => { ov.remove(); startGame(); };
    }

    function setupPlayer(){
      if(!cfg.player?.img) return; 
      playerNode = document.createElement('div');
      playerNode.id = 'player';
      playerNode.style.width = (cfg.player.width||100)+'px';
      playerNode.style.height = (cfg.player.height||100)+'px';
      playerNode.style.backgroundImage = `url(${cfg.player.img})`;
      
      const dir = cfg.direction || 'down';
      
      if(IS_HORIZONTAL) {
         playerPos.y = window.innerHeight / 2;
         if(dir === 'left') {
            playerNode.style.left = '20px'; playerNode.style.top = '50%';
         } else {
            playerNode.style.right = '20px'; playerNode.style.top = '50%';
         }
      } else {
         playerPos.x = window.innerWidth / 2;
         if(dir === 'down') {
            playerNode.style.bottom = '0px'; playerNode.style.left = '50%';
         } else {
            playerNode.style.top = '0px'; playerNode.style.left = '50%';
         }
      }
      $('#game').appendChild(playerNode);
      setupControls();
      requestAnimationFrame(loopPlayer);
    }

    function setupControls(){
      window.onkeydown = e => { 
         if(IS_HORIZONTAL) {
            if(e.key==='ArrowUp') keys.neg=true; if(e.key==='ArrowDown') keys.pos=true;
         } else {
            if(e.key==='ArrowLeft') keys.neg=true; if(e.key==='ArrowRight') keys.pos=true;
         }
      };
      window.onkeyup = e => {
         if(IS_HORIZONTAL) {
            if(e.key==='ArrowUp') keys.neg=false; if(e.key==='ArrowDown') keys.pos=false;
         } else {
            if(e.key==='ArrowLeft') keys.neg=false; if(e.key==='ArrowRight') keys.pos=false;
         }
      };
      const gameDiv = $('#game');
      const z1 = document.createElement('div'); z1.className='touch-zone';
      const z2 = document.createElement('div'); z2.className='touch-zone';
      if(IS_HORIZONTAL) {
         z1.style.cssText = "top:0; left:0; right:0; height:50%"; z2.style.cssText = "bottom:0; left:0; right:0; height:50%";
      } else {
         z1.style.cssText = "top:0; left:0; bottom:0; width:50%"; z2.style.cssText = "top:0; right:0; bottom:0; width:50%";
      }
      const bind = (el, k) => {
        el.ontouchstart = e => { e.preventDefault(); keys[k]=true; };
        el.ontouchend = e => { e.preventDefault(); keys[k]=false; };
        el.onmousedown = () => keys[k]=true; el.onmouseup = () => keys[k]=false; el.onmouseleave = () => keys[k]=false;
      };
      bind(z1, 'neg'); bind(z2, 'pos');
      gameDiv.appendChild(z1); gameDiv.appendChild(z2);
    }

    function loopPlayer(){
      if(!playerNode || !running) { requestAnimationFrame(loopPlayer); return; }
      if(keys.neg) playerPos.v -= 1.5; if(keys.pos) playerPos.v += 1.5;
      playerPos.v *= 0.85;

      if(IS_HORIZONTAL) {
         playerPos.y += playerPos.v;
         const h = playerNode.offsetHeight;
         if(playerPos.y < h/2) { playerPos.y = h/2; playerPos.v=0; }
         if(playerPos.y > window.innerHeight - h/2) { playerPos.y = window.innerHeight - h/2; playerPos.v=0; }
         playerNode.style.top = playerPos.y + 'px'; playerNode.style.transform = 'translateY(-50%)'; 
      } else {
         playerPos.x += playerPos.v;
         const w = playerNode.offsetWidth;
         if(playerPos.x < w/2) { playerPos.x = w/2; playerPos.v=0; }
         if(playerPos.x > window.innerWidth - w/2) { playerPos.x = window.innerWidth - w/2; playerPos.v=0; }
         playerNode.style.left = playerPos.x + 'px'; playerNode.style.transform = 'translateX(-50%)'; 
      }
      checkCollisions();
      requestAnimationFrame(loopPlayer);
    }

    function startGame(){
      score=0; hits=0; wrongClicks=0; missed=0; currentLevel=0; running=true;
      $('#hudScore').textContent = '0';
      $('.hud').style.display = 'flex';
      if(playerNode) playerNode.style.display = 'block';
      startLevel();
    }

    function startLevel(){
      if(spawnTimer) clearTimeout(spawnTimer); 
      document.querySelectorAll('.item').forEach(e=>e.remove()); 
      
      currentLevel++;
      if(currentLevel > cfg.levels.length) { gameOver(); return; }
      const lv = cfg.levels[currentLevel-1];
      $('#hudLevel').textContent = lv.target || `${currentLevel}`;
      
      let time = lv.timer || 30;
      $('#hudTimer').textContent = time;
      
      const timer = setInterval(() => {
        if(!running) return clearInterval(timer);
        time--;
        $('#hudTimer').textContent = time;
        if(time <= 0) {
          clearInterval(timer); clearTimeout(spawnTimer); 
          document.querySelectorAll('.item').forEach(e=>e.remove());
          showLevelComplete();
        }
      }, 1000);
      spawnLoop(lv);
    }

    function spawnLoop(lv){
      const pool = [...lv.correct.map(v=>({v,g:true})), ...lv.wrong.map(v=>({v,g:false}))];
      const next = () => {
         if(!running) return;
         if(document.querySelectorAll('.item').length < 6) drop(pool[Math.floor(Math.random()*pool.length)]);
         spawnTimer = setTimeout(next, SPEED.spawn);
      };
      next();
    }

    function drop(data){
      const STYLE = cfg.style || {};
      const FONT = cfg.font || 'sans-serif';
      const FONT_SIZE = Number(cfg.fontSize || 24);
      const TEXT_COLOR = cfg.textColor || '#ffffff';
      
      const el = document.createElement('div');
      el.className = `item shape-${STYLE.shape || 'rounded'} ${STYLE.shadow?'fx-shadow':''} ${STYLE.fx3d?'fx-3d':''} ${STYLE.glow?'fx-glow':''}`;
      el.dataset.good = data.g;
      
      const bg = document.createElement('div');
      bg.className = 'bg';
      
      if(STYLE.bgImages && STYLE.bgImages.length) {
         const pick = STYLE.bgImages[Math.floor(Math.random()*STYLE.bgImages.length)];
         bg.style.backgroundImage = `url(${pick})`;
      } else if(STYLE.bgImage) {
         const list = String(STYLE.bgImage).split(/[\n\r,|;]+/).map(s=>s.trim()).filter(Boolean);
         if(list.length) bg.style.backgroundImage = `url(${list[Math.floor(Math.random()*list.length)]})`;
      } else if(STYLE.bgColor) {
         bg.style.backgroundColor = STYLE.bgColor;
      }
      
      bg.style.opacity = STYLE.opacity || 1;
      if(STYLE.borderOn) bg.style.border = `2px solid ${STYLE.borderColor}`;

      const con = document.createElement('div');
      con.className = 'content';
      
      // –ü–∞–¥–¥–∏–Ω–≥–∏ –∏–∑ –∫–æ–Ω—Ñ–∏–≥–∞ –¥–ª—è –∫–æ–Ω—Ç–µ–Ω—Ç–∞
      const PAD = Number(STYLE.pad || 22);
      con.style.padding = `6px ${PAD}px`;
      
      const IMG_BOX = Number(STYLE.imgBox || 160);

      if(/^https?:\/\//i.test(data.v)){
         const img = document.createElement('img');
         img.src = data.v;
         con.appendChild(img);
         con.style.setProperty('--cw', IMG_BOX + 'px');
         con.style.setProperty('--ch', IMG_BOX + 'px');
      } else {
         const span = document.createElement('span');
         if(cfg.language==='math') { 
             span.textContent = `\\(${data.v}\\)`; 
         } else {
             span.textContent = data.v;
         }
         span.style.color = TEXT_COLOR;
         span.style.fontSize = `${FONT_SIZE}px`;
         span.style.fontFamily = FONT;
         con.appendChild(span);
      }
      
      el.appendChild(bg); el.appendChild(con);
      $('#game').appendChild(el);
      
      if(cfg.language==='math') {
          MathJax.typesetPromise([el]).then(() => {
             fitGeometryBox(el, STYLE);
             setStartPosition(el);
          });
      } else {
         fitGeometryBox(el, STYLE);
         setStartPosition(el);
      }
      
      startFalling(el);
      if(!playerNode) el.onclick = () => catchItem(el);
    }
    
    // === –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –†–ê–°–ß–ï–¢ –†–ê–ó–ú–ï–†–û–í (–ß—Ç–æ–±—ã —Ñ—Ä—É–∫—Ç –≤—Å–µ–≥–¥–∞ –Ω–∞–∫—Ä—ã–≤–∞–ª —Ç–µ–∫—Å—Ç) ===
    function fitGeometryBox(el, STYLE){
       const content = el.querySelector('.content');
       if(!content) return;
       
       el.style.width = ''; el.style.height='';
       
       const r = content.getBoundingClientRect();
       const PAD = Number(STYLE.pad || 22);

       // –ë–µ—Ä–µ–º —à–∏—Ä–∏–Ω—É —Ç–µ–∫—Å—Ç–∞ –∏ –¥–æ–±–∞–≤–ª—è–µ–º –ø–∞–¥–¥–∏–Ω–≥–∏, —á—Ç–æ–±—ã —Ñ—Ä—É–∫—Ç –±—ã–ª –±–æ–ª—å—à–µ —Ç–µ–∫—Å—Ç–∞
       let W = Math.ceil(r.width + (PAD * 1.5)); 
       let H = Math.ceil(r.height + 10); // –ù–µ–º–Ω–æ–≥–æ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–≥–æ –∑–∞–ø–∞—Å–∞

       const shape = STYLE.shape || 'rounded';
       if (shape === 'circle' || shape === 'diamond' || shape === 'star'){
           const S = Math.max(W, H);
           W = H = Math.ceil(S + 10);
       }
       
       el.style.width = W + 'px';
       el.style.height = H + 'px';
    }

    // === –°–ò–°–¢–ï–ú–ê –ó–û–ù (–ê–ù–¢–ò-–ö–£–ß–ö–û–í–ê–ù–ò–ï) ===
    function setStartPosition(el) {
      const dir = cfg.direction || 'down';
      const elW = el.offsetWidth || 100;
      const elH = el.offsetHeight || 80;
      
      let x, y;

      if (IS_HORIZONTAL) {
          const zones = 3;
          const H = window.innerHeight;
          const zoneH = (H - 100) / zones; 
          
          let z;
          let tries = 0;
          do {
             z = Math.floor(Math.random() * zones);
             tries++;
          } while(z === lastZone && tries < 5);
          lastZone = z;
          
          const minY = 50 + (z * zoneH);
          const maxY = 50 + ((z+1) * zoneH) - elH;
          y = minY + Math.random() * (maxY - minY);
          
          if(dir === 'left') x = (window.innerWidth + 100); 
          else x = -250; 
          
      } else {
          const zones = 4;
          const W = window.innerWidth;
          const zoneW = (W - 40) / zones; 
          
          let z;
          let tries = 0;
          do {
             z = Math.floor(Math.random() * zones);
             tries++;
          } while(z === lastZone && tries < 5);
          lastZone = z;
          
          const minX = 20 + (z * zoneW);
          const maxX = 20 + ((z+1) * zoneW) - elW;
          x = minX + Math.random() * (maxX - minX);
          
          if(dir === 'down') y = -250;
          else y = (window.innerHeight + 50);
      }
      
      el.style.left = x + 'px';
      el.style.top = y + 'px';
    }

    function startFalling(el) {
       let t = Math.random() * 100;
       const speed = SPEED.vel;
       const dir = cfg.direction || 'down';
       
       function fall(){
        if(!el.parentNode) return;
        t += 0.05;
        const sway = Math.sin(t) * 25; 
        
        if(IS_HORIZONTAL) {
           let x = parseFloat(el.style.left);
           if(dir === 'left') x -= speed; else x += speed;
           el.style.left = x + 'px';
           el.style.transform = `translateY(${sway}px)`;
           if(x < -300 || x > window.innerWidth+300) {
              if(el.dataset.good === 'true') missed++;
              el.remove();
           } else requestAnimationFrame(fall);
        } else {
           let y = parseFloat(el.style.top);
           if(dir === 'down') y += speed; else y -= speed;
           
           let curX = parseFloat(el.style.left);
           if(curX + sway < 10) el.style.left = (curX + (10 - (curX+sway))) + 'px';
           else if (curX + sway > window.innerWidth - el.offsetWidth - 10) el.style.left = (curX - ((curX+sway) - (window.innerWidth - el.offsetWidth - 10))) + 'px';
           
           el.style.top = y + 'px';
           el.style.transform = `translateX(${sway}px)`;
           
           if(y > window.innerHeight+300 || y < -300) {
              if(el.dataset.good === 'true') missed++;
              el.remove();
           } else requestAnimationFrame(fall);
        }
      }
      requestAnimationFrame(fall);
    }

    function checkCollisions(){
      const pRect = playerNode.getBoundingClientRect();
      const hit = { 
         l: pRect.left + pRect.width*0.2, r: pRect.right - pRect.width*0.2, 
         t: pRect.top + pRect.height*0.2, b: pRect.bottom - pRect.height*0.2 
      };
      document.querySelectorAll('.item').forEach(el => {
        if(el.dataset.caught) return;
        const r = el.getBoundingClientRect();
        if(!(hit.r < r.left || hit.l > r.right || hit.b < r.top || hit.t > r.bottom)){
            catchItem(el);
        }
      });
    }

    function catchItem(el){
      el.dataset.caught = true;
      const isGood = el.dataset.good === 'true';
      if(isGood) {
        score += SPEED.basePts; hits++;
        floatText(el, "+"+SPEED.basePts, "#0f0");
        try{ SND.pop.currentTime=0; SND.pop.play() }catch(e){}
      } else {
        score = Math.max(0, score - SPEED.basePts); wrongClicks++;
        floatText(el, "-"+SPEED.basePts, "#f00");
        try{ SND.wrong.currentTime=0; SND.wrong.play() }catch(e){}
        if(playerNode) {
             playerNode.style.filter = "grayscale(1) sepia(1) hue-rotate(-50deg) saturate(5)";
             setTimeout(()=>playerNode.style.filter="", 300);
        }
        el.classList.add('tint-red');
        setTimeout(()=>el.classList.remove('tint-red'), 300);
      }
      $('#hudScore').textContent = score;
      el.classList.add('caught');
      setTimeout(()=>el.remove(), 200);
    }

    function floatText(el, txt, col){
       const f = document.createElement('div'); f.className='score-float';
       f.textContent = txt; f.style.color = col;
       const r = el.getBoundingClientRect();
       f.style.left = (r.left+r.width/2)+'px'; f.style.top = r.top+'px';
       document.body.appendChild(f);
       setTimeout(()=>f.remove(), 800);
    }

    function showLevelComplete(){
      const ov = document.createElement('div'); ov.className='overlay';
      try{ SND.win.currentTime=0; SND.win.play() }catch(e){}
      ov.innerHTML = `<div class="panel"><h2>Level Complete!</h2><button onclick="this.closest('.overlay').remove();startLevel()">Next</button></div>`;
      document.body.appendChild(ov);
      launchFireworks(15);
    }
    
    function gameOver(){
      const ov = document.createElement('div'); ov.className='overlay';
      try{ SND.win.currentTime=0; SND.win.play() }catch(e){}
      const ranks = t(LANG, 'ranks');
      let rankIdx = 0; if (score >= 50) rankIdx = 1; if (score >= 150) rankIdx = 2; if (score >= 300) rankIdx = 3; if (score >= 500) rankIdx = 4;
      const rankName = ranks[rankIdx];
      const TXT = t(LANG, 'stats');
      const fbVal = cfg.finalFeedback || 'Good Job!';
      let fbContent = /^https?:\/\//i.test(fbVal) ? `<img src="${fbVal}" class="feedback-img">` : `<h2>${fbVal}</h2>`;

      ov.innerHTML = `
        <div class="panel">
           ${fbContent}
           <h3 class="rank">${rankName}</h3>
           <div class="stats-grid">
             <div class="stats-row"><span>‚úÖ ${TXT.hits}</span> <b>${hits}</b></div>
             <div class="stats-row"><span>‚ùå ${TXT.wrong}</span> <b>${wrongClicks}</b></div>
             <div class="stats-row"><span>üí® ${TXT.missed}</span> <b>${missed}</b></div>
             <div class="stats-row"><span>üèÜ ${TXT.total}</span> <b>${score}</b></div>
           </div>
           <button onclick="location.reload()">Replay</button>
        </div>`;
      document.body.appendChild(ov);
      launchFireworks(40);
    }

    function launchFireworks(count){
       for(let i=0; i<count; i++){
          setTimeout(()=>{
             const x = Math.random() * window.innerWidth;
             const y = Math.random() * window.innerHeight * 0.6;
             createFirework(x, y);
          }, i * 300);
       }
    }
    function createFirework(x, y) {
      const colors = ['#ff0', '#f0f', '#0ff', '#0f0', '#f00'];
      const color = colors[Math.floor(Math.random() * colors.length)];
      for (let i = 0; i < 20; i++) {
        const p = document.createElement('div'); p.className = 'firework';
        p.style.backgroundColor = color; p.style.left = x + 'px'; p.style.top = y + 'px';
        const angle = (Math.PI * 2 * i) / 20; const speed = Math.random() * 5 + 2;
        const vx = Math.cos(angle) * speed; const vy = Math.sin(angle) * speed;
        document.body.appendChild(p);
        let life = 100;
        const anim = setInterval(() => {
           const l = parseFloat(p.style.left); const t = parseFloat(p.style.top);
           p.style.left = (l + vx) + 'px'; p.style.top = (t + vy) + 'px'; p.style.opacity = life / 100;
           life -= 2; if(life <= 0) { clearInterval(anim); p.remove(); }
        }, 20);
      }
    }
  </script>
</body>
</html>
